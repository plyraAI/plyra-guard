{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Plyra Guard","text":"Plyra Guard <p>Production-grade action middleware for agentic AI</p> <p> Stop your agents before they do something irreversible. Plyra Guard intercepts every tool call, evaluates it against your policy, and blocks, logs, or escalates \u2014 in under 2ms. </p>   [![PyPI](https://img.shields.io/pypi/v/plyra-guard?color=2dd4bf&amp;labelColor=0d1117)](https://pypi.org/project/plyra-guard) [![Python](https://img.shields.io/pypi/pyversions/plyra-guard?color=2dd4bf&amp;labelColor=0d1117)](https://pypi.org/project/plyra-guard) [![License](https://img.shields.io/badge/license-Apache%202.0-2dd4bf?labelColor=0d1117)](https://github.com/plyraAI/plyra-guard/blob/main/LICENSE) [![Tests](https://img.shields.io/github/actions/workflow/status/plyraAI/plyra-guard/ci.yml?color=2dd4bf&amp;labelColor=0d1117&amp;label=tests)](https://github.com/plyraAI/plyra-guard/actions)   <p>Get Started View on GitHub</p>"},{"location":"#why-plyra-guard","title":"Why Plyra Guard?","text":"<p>LLM agents fail in the same ways: they delete files they shouldn't, call APIs with wrong credentials, exfiltrate data, or loop forever. These aren't model problems \u2014 they're infrastructure problems. Plyra Guard is the missing safety layer.</p> \u26a1 \ud83d\udee1\ufe0f \ud83d\udcca \ud83d\udd0d"},{"location":"#framework-agnostic","title":"Framework Agnostic","text":"<p>One-line wrap for LangChain, LangGraph, AutoGen, CrewAI, OpenAI, Anthropic, or any Python function.</p>"},{"location":"#policy-as-code","title":"Policy as Code","text":"<p>Define allow/block rules in YAML or Python. Regex, semantic, and custom evaluators supported.</p>"},{"location":"#built-in-dashboard","title":"Built-in Dashboard","text":"<p>Real-time action feed, policy hit rates, agent session replay \u2014 all in a local web UI.</p>"},{"location":"#full-observability","title":"Full Observability","text":"<p>OpenTelemetry, Datadog, and stdout exporters. Every action logged with intent, outcome, and latency.</p>"},{"location":"#60-second-install","title":"60-Second Install","text":"<pre><code>pip install plyra-guard\n</code></pre> <pre><code>from plyra_guard import ActionGuard\n\nguard = ActionGuard()\n\n@guard.wrap\ndef delete_file(path: str) -&gt; str:\n    import os\n    os.remove(path)\n    return f\"Deleted {path}\"\n\n# Safe call \u2014 allowed\ndelete_file(\"/tmp/report.txt\")\n\n# Blocked by default policy\ndelete_file(\"/etc/passwd\")  # \u2192 PolicyViolationError\n</code></pre>"},{"location":"#framework-support","title":"Framework Support","text":"Framework Status Pattern LangChain \u2705 <code>guard.wrap(tools)</code> LangGraph \u2705 Custom tool node AutoGen \u2705 <code>guard.wrap([func])</code> CrewAI \u2705 <code>guard.wrap(tools)</code> OpenAI \u2705 Function call interceptor Anthropic \u2705 Tool use interceptor Plain Python \u2705 <code>@guard.wrap</code> decorator"},{"location":"api/action-guard/","title":"ActionGuard","text":"<p>The central class. Create one per application (or one per agent for separate policies).</p>"},{"location":"api/action-guard/#constructor","title":"Constructor","text":"<pre><code>ActionGuard(\n    policy: Policy | None = None,\n    exporters: list[Exporter] | None = None,\n    snapshot_path: str | None = \"~/.plyra/snapshots.db\",\n)\n</code></pre> Parameter Type Default Description <code>policy</code> <code>Policy</code> built-in defaults Policy to evaluate actions against <code>exporters</code> <code>list[Exporter]</code> <code>[StdoutExporter()]</code> Where to send action logs <code>snapshot_path</code> <code>str \\| None</code> <code>~/.plyra/snapshots.db</code> SQLite file for persistent history. <code>None</code> to disable."},{"location":"api/action-guard/#class-methods","title":"Class Methods","text":""},{"location":"api/action-guard/#from_config","title":"<code>from_config</code>","text":"<pre><code>@classmethod\ndef from_config(cls, path: str) -&gt; ActionGuard\n</code></pre> <p>Load a guard from a YAML policy file.</p> <pre><code>guard = ActionGuard.from_config(\"policy.yaml\")\n</code></pre>"},{"location":"api/action-guard/#instance-methods","title":"Instance Methods","text":""},{"location":"api/action-guard/#wrap","title":"<code>wrap</code>","text":"<pre><code>def wrap(\n    fn: Callable | list[Callable],\n    *,\n    intent_fn: Callable | None = None,\n) -&gt; Callable | list[Callable]\n</code></pre> <p>Wrap one or more callables with policy evaluation. Can be used as a decorator or called directly.</p> <pre><code># Decorator\n@guard.wrap\ndef my_tool(path: str) -&gt; str: ...\n\n# Direct call\nsafe_tools = guard.wrap([tool1, tool2, tool3])\n\n# Custom intent extraction\n@guard.wrap(intent_fn=lambda args, kwargs: kwargs.get(\"path\", \"\"))\ndef delete_file(path: str) -&gt; None: ...\n</code></pre>"},{"location":"api/action-guard/#evaluate","title":"<code>evaluate</code>","text":"<pre><code>def evaluate(intent: str) -&gt; EvaluationResult\n</code></pre> <p>Evaluate an intent string against the policy without executing any tool. Useful for testing policies or pre-checking before expensive operations.</p> <pre><code>result = guard.evaluate(\"rm -rf /var/log\")\nprint(result.outcome)    # \"BLOCK\"\nprint(result.reason)     # \"No recursive deletes\"\nprint(result.rule_name)  # \"no-rm-rf\"\nprint(result.latency_ms) # 0.3\n</code></pre>"},{"location":"api/action-guard/#history","title":"<code>history</code>","text":"<pre><code>def history(\n    limit: int = 100,\n    outcome: str | None = None,\n    tool_name: str | None = None,\n    since: datetime | None = None,\n) -&gt; list[ActionRecord]\n</code></pre> <p>Query the action log.</p> <pre><code># Last 50 blocks\nblocks = guard.history(limit=50, outcome=\"BLOCK\")\n\n# All delete_file calls today\nfrom datetime import datetime, timedelta\ntoday = datetime.now() - timedelta(hours=24)\ndeletes = guard.history(tool_name=\"delete_file\", since=today)\n</code></pre>"},{"location":"api/action-guard/#evaluationresult","title":"<code>EvaluationResult</code>","text":"Field Type Description <code>outcome</code> <code>str</code> <code>\"ALLOW\"</code>, <code>\"BLOCK\"</code>, or <code>\"ESCALATE\"</code> <code>reason</code> <code>str</code> Human-readable explanation <code>rule_name</code> <code>str \\| None</code> Name of the matching rule <code>latency_ms</code> <code>float</code> Evaluation time in milliseconds"},{"location":"api/action-guard/#actionrecord","title":"<code>ActionRecord</code>","text":"Field Type Description <code>id</code> <code>str</code> UUID <code>tool_name</code> <code>str</code> Name of the wrapped function <code>intent</code> <code>str</code> Intent string evaluated <code>outcome</code> <code>str</code> <code>\"ALLOW\"</code>, <code>\"BLOCK\"</code>, <code>\"ESCALATE\"</code>, <code>\"ERROR\"</code> <code>reason</code> <code>str</code> Why this outcome was chosen <code>latency_ms</code> <code>float</code> End-to-end time including tool execution <code>timestamp</code> <code>datetime</code> When the action occurred <code>args</code> <code>dict</code> Full argument payload <code>result</code> <code>Any</code> Return value (None if blocked) <code>error</code> <code>str \\| None</code> Exception message if outcome is ERROR"},{"location":"api/adapters/","title":"Adapters &amp; Exporters","text":""},{"location":"api/adapters/#exporters","title":"Exporters","text":"<p>Exporters receive every <code>ActionRecord</code> after evaluation and route it to your observability stack.</p>"},{"location":"api/adapters/#stdoutexporter-default","title":"StdoutExporter (default)","text":"<p>Logs to stdout in a structured format. Active by default \u2014 useful during development.</p> <pre><code>from plyra_guard.exporters import StdoutExporter\n\nguard = ActionGuard(exporters=[StdoutExporter(level=\"INFO\")])\n</code></pre> <p>Disable by passing an empty list:</p> <pre><code>guard = ActionGuard(exporters=[])\n</code></pre>"},{"location":"api/adapters/#otelexporter","title":"OtelExporter","text":"<p>Ships actions as OpenTelemetry spans.</p> <pre><code>pip install \"plyra-guard[otel]\"\n</code></pre> <pre><code>from plyra_guard.exporters import OtelExporter\n\nguard = ActionGuard(exporters=[\n    OtelExporter(endpoint=\"http://localhost:4317\")\n])\n</code></pre>"},{"location":"api/adapters/#datadogexporter","title":"DatadogExporter","text":"<p>Ships actions as Datadog custom events.</p> <pre><code>pip install \"plyra-guard[datadog]\"\n</code></pre> <pre><code>from plyra_guard.exporters import DatadogExporter\n\nguard = ActionGuard(exporters=[\n    DatadogExporter(service=\"my-agent\", env=\"production\")\n])\n</code></pre>"},{"location":"api/adapters/#sidecarexporter","title":"SidecarExporter","text":"<p>Streams actions to the local dashboard sidecar.</p> <pre><code>pip install \"plyra-guard[sidecar]\"\n</code></pre> <pre><code>from plyra_guard.exporters import SidecarExporter\n\nguard = ActionGuard(exporters=[\n    SidecarExporter(url=\"http://localhost:8765\")\n])\n</code></pre>"},{"location":"api/adapters/#multiple-exporters","title":"Multiple Exporters","text":"<pre><code>guard = ActionGuard(exporters=[\n    StdoutExporter(),\n    OtelExporter(endpoint=\"http://otel-collector:4317\"),\n    SidecarExporter(),\n])\n</code></pre>"},{"location":"api/adapters/#custom-exporter","title":"Custom Exporter","text":"<p>Implement the <code>Exporter</code> protocol:</p> <pre><code>from plyra_guard.exporters import Exporter\nfrom plyra_guard.models import ActionRecord\n\nclass MyExporter(Exporter):\n    def export(self, action: ActionRecord) -&gt; None:\n        # your logic here\n        my_db.insert(action.model_dump())\n</code></pre>"},{"location":"api/adapters/#exceptions","title":"Exceptions","text":""},{"location":"api/adapters/#policyviolationerror","title":"<code>PolicyViolationError</code>","text":"<p>Raised when a wrapped tool call is blocked.</p> <pre><code>from plyra_guard.exceptions import PolicyViolationError\n\ntry:\n    delete_file(\"/etc/passwd\")\nexcept PolicyViolationError as e:\n    print(e.reason)    # \"System config is off-limits\"\n    print(e.rule_name) # \"protect-system\"\n    print(e.intent)    # \"/etc/passwd\"\n</code></pre>"},{"location":"api/adapters/#actionguardexecutionerror","title":"<code>ActionGuardExecutionError</code>","text":"<p>Raised in CrewAI context (subclass of <code>PolicyViolationError</code>). Same fields.</p>"},{"location":"api/policy/","title":"Policy &amp; Rule","text":""},{"location":"api/policy/#policy","title":"Policy","text":"<pre><code>Policy(\n    rules: list[Rule],\n    name: str = \"default\",\n    default_action: Literal[\"allow\", \"block\"] = \"block\",\n)\n</code></pre> Parameter Type Default Description <code>rules</code> <code>list[Rule]</code> required Ordered list of rules. First match wins. <code>name</code> <code>str</code> <code>\"default\"</code> Policy name (appears in logs) <code>default_action</code> <code>str</code> <code>\"block\"</code> Action when no rule matches"},{"location":"api/policy/#methods","title":"Methods","text":"<pre><code>policy.evaluate(intent: str) -&gt; EvaluationResult\n</code></pre> <p>Evaluate an intent string and return the result.</p> <pre><code>policy.add_rule(rule: Rule, index: int | None = None) -&gt; None\n</code></pre> <p>Add a rule at a given position (default: append to end).</p>"},{"location":"api/policy/#rule","title":"Rule","text":"<pre><code>Rule(\n    pattern: str,\n    action: Literal[\"allow\", \"block\", \"escalate\"],\n    reason: str = \"\",\n    name: str | None = None,\n)\n</code></pre> Parameter Type Default Description <code>pattern</code> <code>str</code> required Python regex matched against intent <code>action</code> <code>str</code> required <code>\"allow\"</code>, <code>\"block\"</code>, or <code>\"escalate\"</code> <code>reason</code> <code>str</code> <code>\"\"</code> Human-readable explanation (logged) <code>name</code> <code>str</code> auto Rule identifier for logs"},{"location":"api/policy/#pattern-matching","title":"Pattern Matching","text":"<p>Patterns use <code>re.search()</code> \u2014 the pattern can match anywhere in the intent string unless anchored with <code>^</code> or <code>$</code>.</p> <pre><code># Matches /etc/anything\nRule(pattern=r\"^/etc/\", action=\"block\")\n\n# Matches any .env file anywhere in the path\nRule(pattern=r\"\\.env$\", action=\"block\")\n\n# Matches exact string \"DROP TABLE\"\nRule(pattern=r\"DROP TABLE\", action=\"block\")\n</code></pre>"},{"location":"api/policy/#escalation","title":"Escalation","text":"<p><code>escalate</code> pauses the action and waits for human approval. Requires an escalation handler to be configured:</p> <pre><code>async def my_approval_handler(action: ActionRecord) -&gt; bool:\n    # Return True to approve, False to deny\n    response = await send_slack_approval(action)\n    return response == \"approve\"\n\nguard = ActionGuard(\n    policy=policy,\n    escalation_handler=my_approval_handler,\n)\n</code></pre>"},{"location":"getting-started/concepts/","title":"Core Concepts","text":""},{"location":"getting-started/concepts/#how-it-works","title":"How It Works","text":"<p>Every tool call your agent makes flows through Plyra Guard's evaluation pipeline:</p> <pre><code>flowchart LR\n  A[\"Agent\"] --&gt;|\"tool_call\"| B[\"ActionGuard\"]\n  B --&gt; C[\"Policy Evaluator\"]\n  C --&gt;|\"ALLOW\"| D[\"Execute Tool\"]\n  C --&gt;|\"BLOCK\"| E[\"PolicyViolationError\"]\n  C --&gt;|\"ESCALATE\"| F[\"Human Review\"]\n  D --&gt; G[\"Log + Return Result\"]\n  E --&gt; G</code></pre>"},{"location":"getting-started/concepts/#key-concepts","title":"Key Concepts","text":""},{"location":"getting-started/concepts/#actionguard","title":"ActionGuard","text":"<p>The central object. One instance per agent (or shared across agents). Holds your policy, exporters, and action history.</p> <pre><code>guard = ActionGuard(\n    policy=my_policy,       # optional \u2014 defaults to sensible rules\n    exporters=[...],        # optional \u2014 stdout, OTEL, Datadog\n    snapshot_path=\"~/.plyra/snapshots.db\"  # optional \u2014 local SQLite history\n)\n</code></pre>"},{"location":"getting-started/concepts/#policy","title":"Policy","text":"<p>A policy is an ordered list of Rules. The first matching rule wins.</p> <pre><code>policy = Policy(rules=[\n    Rule(pattern=r\"^/etc/\", action=\"block\"),\n    Rule(pattern=r\"^/tmp/\", action=\"allow\"),\n    Rule(pattern=\".*\",      action=\"block\"),  # default deny\n])\n</code></pre>"},{"location":"getting-started/concepts/#rule","title":"Rule","text":"<p>A rule has three parts:</p> Field Type Description <code>pattern</code> <code>str</code> Regex matched against the intent string <code>action</code> <code>\"allow\"</code> | <code>\"block\"</code> | <code>\"escalate\"</code> What to do on match <code>reason</code> <code>str</code> Human-readable explanation (logged)"},{"location":"getting-started/concepts/#intent","title":"Intent","text":"<p>When your agent calls a wrapped tool, Plyra Guard extracts an intent string from the call arguments. This string is what gets matched against your policy rules.</p> <p>By default, intent is the concatenation of all string arguments. You can customise it:</p> <pre><code>@guard.wrap(intent_fn=lambda args, kwargs: kwargs.get(\"path\", \"\"))\ndef delete_file(path: str) -&gt; None:\n    ...\n</code></pre>"},{"location":"getting-started/concepts/#outcomes","title":"Outcomes","text":"Outcome Meaning <code>ALLOW</code> Tool executed normally <code>BLOCK</code> Tool not executed, <code>PolicyViolationError</code> raised <code>ESCALATE</code> Paused, waiting for human approval (async) <code>ERROR</code> Tool raised an exception (still logged)"},{"location":"getting-started/concepts/#action-log","title":"Action Log","text":"<p>Every call \u2014 allowed or blocked \u2014 is written to the action log. By default this is an in-memory ring buffer + optional SQLite snapshot file at <code>~/.plyra/snapshots.db</code>.</p> <pre><code># Query recent actions\nactions = guard.history(limit=50, outcome=\"BLOCK\")\nfor a in actions:\n    print(f\"{a.tool_name} | {a.intent} | {a.outcome} | {a.latency_ms}ms\")\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11, 3.12, or 3.13</li> <li>pip or uv</li> </ul>"},{"location":"getting-started/installation/#basic-install","title":"Basic Install","text":"<pre><code>pip install plyra-guard\n</code></pre> <p>Or with uv (recommended):</p> <pre><code>uv add plyra-guard\n</code></pre>"},{"location":"getting-started/installation/#optional-extras","title":"Optional Extras","text":"<p>Plyra Guard is modular. Install only what you need:</p> <pre><code># Dashboard UI + sidecar API server\npip install \"plyra-guard[sidecar]\"\n\n# OpenTelemetry exporter\npip install \"plyra-guard[otel]\"\n\n# Datadog exporter\npip install \"plyra-guard[datadog]\"\n\n# S3 snapshot storage\npip install \"plyra-guard[storage]\"\n\n# Everything\npip install \"plyra-guard[all]\"\n</code></pre>"},{"location":"getting-started/installation/#verify-install","title":"Verify Install","text":"<pre><code>import plyra_guard\nprint(plyra_guard.__version__)\n</code></pre>"},{"location":"getting-started/installation/#development-install","title":"Development Install","text":"<pre><code>git clone https://github.com/plyraAI/plyra-guard\ncd plyra-guard\nuv sync --all-extras\nuv run pytest\n</code></pre> <p>Tip</p> <p>Use a virtual environment to keep your project dependencies isolated. <code>uv</code> handles this automatically.</p>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>Get Plyra Guard running in under 5 minutes.</p>"},{"location":"getting-started/quickstart/#1-install","title":"1. Install","text":"<pre><code>pip install plyra-guard\n</code></pre>"},{"location":"getting-started/quickstart/#2-wrap-your-first-tool","title":"2. Wrap Your First Tool","text":"<pre><code>from plyra_guard import ActionGuard\n\nguard = ActionGuard()\n\n@guard.wrap\ndef read_file(path: str) -&gt; str:\n    with open(path) as f:\n        return f.read()\n\n@guard.wrap\ndef delete_file(path: str) -&gt; str:\n    import os\n    os.remove(path)\n    return f\"Deleted {path}\"\n\n# This works \u2014 /tmp is allowed\ncontent = read_file(\"/tmp/data.txt\")\n\n# This is blocked \u2014 /etc is protected\ndelete_file(\"/etc/passwd\")  # raises PolicyViolationError\n</code></pre>"},{"location":"getting-started/quickstart/#3-check-what-happened","title":"3. Check What Happened","text":"<pre><code># Print the last 10 actions\nfor action in guard.history(limit=10):\n    print(action.intent, action.outcome, action.latency_ms)\n</code></pre>"},{"location":"getting-started/quickstart/#4-add-a-custom-policy","title":"4. Add a Custom Policy","text":"<pre><code>from plyra_guard import ActionGuard, Policy, Rule\n\npolicy = Policy(\n    rules=[\n        Rule(pattern=r\"\\.env$\", action=\"block\", reason=\"No .env access\"),\n        Rule(pattern=r\"^/prod/\", action=\"block\", reason=\"Production is read-only\"),\n        Rule(pattern=r\"^/tmp/\", action=\"allow\"),\n    ]\n)\n\nguard = ActionGuard(policy=policy)\n</code></pre> <p>Or load from YAML:</p> policy.yaml<pre><code>rules:\n  - pattern: \"\\.env$\"\n    action: block\n    reason: \"No .env access\"\n  - pattern: \"^/prod/\"\n    action: block\n    reason: \"Production is read-only\"\n  - pattern: \"^/tmp/\"\n    action: allow\n</code></pre> <pre><code>guard = ActionGuard.from_config(\"policy.yaml\")\n</code></pre>"},{"location":"getting-started/quickstart/#5-launch-the-dashboard","title":"5. Launch the Dashboard","text":"<pre><code>pip install \"plyra-guard[sidecar]\"\nplyra-guard serve\n</code></pre> <p>Open http://localhost:8765 to see your real-time action feed.</p>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Core Concepts \u2014 understand how evaluation works</li> <li>Policy Configuration \u2014 full policy reference</li> <li>Framework Integrations \u2014 LangGraph, AutoGen, CrewAI</li> </ul>"},{"location":"guides/dashboard/","title":"Dashboard &amp; Sidecar","text":"<p>Plyra Guard includes a built-in web dashboard and REST API sidecar for real-time monitoring.</p>"},{"location":"guides/dashboard/#install","title":"Install","text":"<pre><code>pip install \"plyra-guard[sidecar]\"\n</code></pre>"},{"location":"guides/dashboard/#start-the-dashboard","title":"Start the Dashboard","text":"<pre><code>plyra-guard serve\n</code></pre> <p>Or with custom options:</p> <pre><code>plyra-guard serve --host 0.0.0.0 --port 8765 --reload\n</code></pre> <p>Open http://localhost:8765 in your browser.</p>"},{"location":"guides/dashboard/#what-youll-see","title":"What You'll See","text":""},{"location":"guides/dashboard/#action-feed","title":"Action Feed","text":"<p>Real-time stream of every tool call your agents make:</p> <ul> <li>Tool name and intent string</li> <li>Outcome: <code>ALLOW</code> / <code>BLOCK</code> / <code>ESCALATE</code></li> <li>Latency in milliseconds</li> <li>Which policy rule triggered</li> <li>Full argument payload (expandable)</li> </ul>"},{"location":"guides/dashboard/#policy-hit-rates","title":"Policy Hit Rates","text":"<p>Bar chart showing which rules are firing most frequently. Useful for auditing overly broad or permissive rules.</p>"},{"location":"guides/dashboard/#session-replay","title":"Session Replay","text":"<p>Replay any agent session from your snapshot history. See the exact sequence of tool calls, decisions, and results.</p>"},{"location":"guides/dashboard/#sidecar-rest-api","title":"Sidecar REST API","text":"<p>The sidecar exposes a REST API alongside the dashboard:</p> <pre><code>GET  /api/actions          \u2014 list recent actions\nGET  /api/actions/{id}     \u2014 single action detail\nGET  /api/stats            \u2014 aggregate stats\nPOST /api/policy/evaluate  \u2014 evaluate an intent string\nGET  /api/health           \u2014 health check\n</code></pre>"},{"location":"guides/dashboard/#example","title":"Example","text":"<pre><code># Check what your agent has been doing\ncurl http://localhost:8765/api/actions?limit=20&amp;outcome=BLOCK\n\n# Evaluate an intent before running\ncurl -X POST http://localhost:8765/api/policy/evaluate \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"intent\": \"rm -rf /var/log\"}'\n</code></pre>"},{"location":"guides/dashboard/#connecting-your-guard-to-the-sidecar","title":"Connecting Your Guard to the Sidecar","text":"<pre><code>from plyra_guard import ActionGuard\nfrom plyra_guard.exporters import SidecarExporter\n\nguard = ActionGuard(\n    exporters=[SidecarExporter(url=\"http://localhost:8765\")]\n)\n</code></pre> <p>Actions are streamed to the sidecar asynchronously \u2014 no latency impact on your agent.</p>"},{"location":"guides/dashboard/#production-considerations","title":"Production Considerations","text":"<p>CORS</p> <p>The default sidecar allows all origins (<code>*</code>). In production, bind to localhost only or add authentication.</p> <p>Snapshot database</p> <p>Action history is stored in <code>~/.plyra/snapshots.db</code> by default. On a server, set <code>PLYRA_SNAPSHOT_PATH</code> to a persistent volume.</p> <pre><code>export PLYRA_SNAPSHOT_PATH=/data/plyra/snapshots.db\nplyra-guard serve\n</code></pre>"},{"location":"guides/policy-config/","title":"Policy Configuration","text":"<p>Policies are the core of Plyra Guard. They define what your agents are and aren't allowed to do.</p>"},{"location":"guides/policy-config/#yaml-configuration","title":"YAML Configuration","text":"<p>The recommended way to define policies is in a YAML file:</p> policy.yaml<pre><code>version: \"1\"\nname: \"production\"\ndefault_action: block   # what to do if no rule matches (default: block)\n\nrules:\n  # Filesystem\n  - pattern: \"^/etc/\"\n    action: block\n    reason: \"System config is off-limits\"\n\n  - pattern: \"\\\\.env$\"\n    action: block\n    reason: \"No .env file access\"\n\n  - pattern: \"^/tmp/\"\n    action: allow\n    reason: \"Temp directory is safe\"\n\n  # Network\n  - pattern: \"https://internal\\\\.corp\"\n    action: block\n    reason: \"Internal network access not permitted\"\n\n  # Destructive operations\n  - pattern: \"rm -rf\"\n    action: block\n    reason: \"No recursive deletes\"\n\n  - pattern: \"DROP TABLE\"\n    action: escalate\n    reason: \"Schema changes require human approval\"\n</code></pre> <p>Load it with:</p> <pre><code>guard = ActionGuard.from_config(\"policy.yaml\")\n</code></pre>"},{"location":"guides/policy-config/#python-configuration","title":"Python Configuration","text":"<p>For dynamic policies or when you need programmatic control:</p> <pre><code>from plyra_guard import ActionGuard, Policy, Rule\n\npolicy = Policy(\n    name=\"production\",\n    default_action=\"block\",\n    rules=[\n        Rule(\n            pattern=r\"^/etc/\",\n            action=\"block\",\n            reason=\"System config is off-limits\"\n        ),\n        Rule(\n            pattern=r\"^/tmp/\",\n            action=\"allow\",\n            reason=\"Temp directory is safe\"\n        ),\n    ]\n)\n\nguard = ActionGuard(policy=policy)\n</code></pre>"},{"location":"guides/policy-config/#rule-matching","title":"Rule Matching","text":"<p>Rules are evaluated in order \u2014 the first match wins.</p> <pre><code>rules=[\n    Rule(pattern=r\"^/tmp/reports/\", action=\"allow\"),   # more specific first\n    Rule(pattern=r\"^/tmp/\",         action=\"block\"),   # catches everything else in /tmp\n]\n</code></pre> <p>Order matters</p> <p>Put more specific rules before more general ones. A catch-all <code>.*</code> block rule at the top would match everything.</p>"},{"location":"guides/policy-config/#pattern-syntax","title":"Pattern Syntax","text":"<p>Patterns are Python regular expressions matched against the intent string.</p> Pattern Matches <code>^/etc/</code> Any path starting with <code>/etc/</code> <code>\\.env$</code> Any string ending with <code>.env</code> <code>DROP TABLE</code> Any intent containing <code>DROP TABLE</code> <code>^(rm\\|delete)\\s</code> Intent starting with <code>rm</code> or <code>delete</code>"},{"location":"guides/policy-config/#actions","title":"Actions","text":"Action Behaviour <code>allow</code> Tool executes normally <code>block</code> Tool is not called, <code>PolicyViolationError</code> raised immediately <code>escalate</code> Tool is paused, human approval required (async workflows)"},{"location":"guides/policy-config/#default-action","title":"Default Action","text":"<p>If no rule matches, the <code>default_action</code> is applied. It defaults to <code>block</code> \u2014 fail closed.</p> <pre><code>default_action: allow   # permissive (not recommended for production)\ndefault_action: block   # restrictive (recommended)\n</code></pre>"},{"location":"guides/policy-config/#environment-specific-policies","title":"Environment-Specific Policies","text":"<pre><code>import os\nfrom plyra_guard import ActionGuard\n\nconfig_file = f\"policy.{os.getenv('ENV', 'development')}.yaml\"\nguard = ActionGuard.from_config(config_file)\n</code></pre>"},{"location":"guides/policy-config/#testing-your-policy","title":"Testing Your Policy","text":"<pre><code># Dry-run evaluation without executing tools\nresult = guard.evaluate(\"rm -rf /var/log\")\nprint(result.outcome)    # BLOCK\nprint(result.reason)     # \"No recursive deletes\"\nprint(result.rule_name)  # the rule that matched\n</code></pre>"},{"location":"integrations/","title":"Framework Integrations","text":"<p>Plyra Guard works with every major agentic framework. Pick yours:</p> \ud83e\udd9c \ud83e\udd16 \u2693"},{"location":"integrations/#langgraph","title":"LangGraph","text":"<p>Custom tool node pattern. Works with StateGraph and any graph topology.</p>"},{"location":"integrations/#autogen","title":"AutoGen","text":"<p>Wrap registered functions on UserProxyAgent.</p>"},{"location":"integrations/#crewai","title":"CrewAI","text":"<p>Wrap @tool definitions. BlockedActions surface as CrewAI errors.</p>"},{"location":"integrations/#general-pattern","title":"General Pattern","text":"<p>For any framework not listed, the general pattern is:</p> <pre><code>from plyra_guard import ActionGuard\n\nguard = ActionGuard()\n\n# Option A \u2014 decorator\n@guard.wrap\ndef my_tool(arg: str) -&gt; str:\n    ...\n\n# Option B \u2014 wrap a list of tools\nsafe_tools = guard.wrap([tool1, tool2, tool3])\n\n# Option C \u2014 wrap a callable\nsafe_fn = guard.wrap(some_function)\n</code></pre> <p>The wrapped version is a drop-in replacement \u2014 same signature, same return type, raises <code>PolicyViolationError</code> on block.</p>"},{"location":"integrations/autogen/","title":"AutoGen Integration","text":"<p>Plyra Guard integrates with AutoGen via <code>guard.wrap()</code> on functions registered with <code>UserProxyAgent</code>.</p>"},{"location":"integrations/autogen/#basic-usage","title":"Basic Usage","text":"<pre><code>import autogen\nfrom plyra_guard import ActionGuard\n\nguard = ActionGuard()\n\n# Define tools\ndef read_file(path: str) -&gt; str:\n    with open(path) as f:\n        return f.read()\n\ndef delete_file(path: str) -&gt; str:\n    import os\n    os.remove(path)\n    return f\"Deleted {path}\"\n\n# Wrap with guard\nsafe_tools = guard.wrap([read_file, delete_file])\n\n# Register with AutoGen agent\nuser_proxy = autogen.UserProxyAgent(\n    name=\"user_proxy\",\n    human_input_mode=\"NEVER\",\n    max_consecutive_auto_reply=10,\n)\n\nfor tool in safe_tools:\n    user_proxy.register_function(\n        function_map={tool.__name__: tool}\n    )\n</code></pre>"},{"location":"integrations/autogen/#what-happens-on-a-block","title":"What Happens on a Block","text":"<p>When a blocked tool is called, Plyra Guard returns an error string (not an exception) into the AutoGen conversation history. This means:</p> <ul> <li>The conversation continues</li> <li>The assistant sees the error and can try a different approach</li> <li>No crash, no infinite loop from uncaught exceptions</li> </ul> <p>Example conversation log:</p> <pre><code>user_proxy \u2192 assistant: Please clean up /etc/passwd\nassistant \u2192 user_proxy: [calls delete_file(\"/etc/passwd\")]\nuser_proxy \u2192 assistant: [BLOCKED] System config is off-limits (rule: protect-system)\nassistant \u2192 user_proxy: I can't delete that file due to policy restrictions. \n                         Is there a different file you'd like me to remove?\n</code></pre>"},{"location":"integrations/autogen/#with-a-custom-policy","title":"With a Custom Policy","text":"<pre><code>from plyra_guard import Policy, Rule\n\npolicy = Policy(rules=[\n    Rule(pattern=r\"/etc/\",  action=\"block\",  reason=\"System config is off-limits\"),\n    Rule(pattern=r\"rm -rf\", action=\"block\",  reason=\"No recursive deletes\"),\n    Rule(pattern=r\"/tmp/\",  action=\"allow\"),\n])\n\nguard = ActionGuard(policy=policy)\nsafe_tools = guard.wrap([read_file, delete_file])\n</code></pre>"},{"location":"integrations/autogen/#group-chat","title":"Group Chat","text":"<p>For multi-agent group chats, create one guard and share it:</p> <pre><code>guard = ActionGuard(policy=policy)\n\ncoder_tools = guard.wrap([write_code, run_tests])\nops_tools   = guard.wrap([deploy, restart_service])\n\ncoder = autogen.AssistantAgent(\"coder\", ...)\nops   = autogen.AssistantAgent(\"ops\", ...)\n\nuser_proxy.register_function(function_map={\n    **{t.__name__: t for t in coder_tools},\n    **{t.__name__: t for t in ops_tools},\n})\n</code></pre> <p>All actions from both agents are logged in the shared guard history.</p>"},{"location":"integrations/crewai/","title":"CrewAI Integration","text":"<p>Plyra Guard wraps CrewAI <code>@tool</code> definitions. Blocked actions surface as <code>ActionGuardExecutionError</code>, which CrewAI's task loop handles natively.</p>"},{"location":"integrations/crewai/#basic-usage","title":"Basic Usage","text":"<pre><code>from crewai_tools import tool\nfrom plyra_guard import ActionGuard\n\nguard = ActionGuard()\n\n@tool(\"Read File\")\ndef read_file(path: str) -&gt; str:\n    \"\"\"Read a file and return its contents.\"\"\"\n    with open(path) as f:\n        return f.read()\n\n@tool(\"Write File\")\ndef write_file(path: str, content: str) -&gt; str:\n    \"\"\"Write content to a file.\"\"\"\n    with open(path, \"w\") as f:\n        f.write(content)\n    return f\"Written to {path}\"\n\n# Wrap tools\nsafe_tools = guard.wrap([read_file, write_file])\n\n# Use with CrewAI agents\nfrom crewai import Agent, Task, Crew\n\nanalyst = Agent(\n    role=\"Data Analyst\",\n    goal=\"Analyse reports and write summaries\",\n    tools=safe_tools,\n    verbose=True,\n)\n</code></pre>"},{"location":"integrations/crewai/#what-happens-on-a-block","title":"What Happens on a Block","text":"<p>When a blocked tool is called, Plyra Guard raises <code>ActionGuardExecutionError</code>. CrewAI's internal task retry logic catches this and surfaces it as a task failure with the block reason included.</p> <p>The agent's verbose output will show:</p> <pre><code>Action: Write File\nAction Input: {\"path\": \"/etc/config\", \"content\": \"...\"}\nObservation: [BLOCKED] System config is off-limits (rule: protect-system)\n</code></pre>"},{"location":"integrations/crewai/#custom-policy","title":"Custom Policy","text":"<pre><code>from plyra_guard import Policy, Rule\n\npolicy = Policy(rules=[\n    Rule(pattern=r\"^/etc/\",    action=\"block\", reason=\"System config is off-limits\"),\n    Rule(pattern=r\"\\.env$\",    action=\"block\", reason=\"No .env access\"),\n    Rule(pattern=r\"^/tmp/\",    action=\"allow\"),\n    Rule(pattern=r\"^/reports/\",action=\"allow\"),\n])\n\nguard = ActionGuard(policy=policy)\nsafe_tools = guard.wrap([read_file, write_file])\n</code></pre>"},{"location":"integrations/crewai/#multi-agent-crew","title":"Multi-Agent Crew","text":"<p>Share one guard across all agents for unified audit logging:</p> <pre><code>guard = ActionGuard(policy=policy)\n\nresearcher_tools = guard.wrap([search_web, read_file])\nwriter_tools     = guard.wrap([write_file, format_report])\n\nresearcher = Agent(role=\"Researcher\", tools=researcher_tools, ...)\nwriter     = Agent(role=\"Writer\",     tools=writer_tools, ...)\n\ncrew = Crew(agents=[researcher, writer], tasks=[...])\ncrew.kickoff()\n\n# After \u2014 see what both agents did\nfor action in guard.history():\n    print(f\"{action.agent_hint} | {action.tool_name} | {action.outcome}\")\n</code></pre>"},{"location":"integrations/crewai/#tips","title":"Tips","text":"<p>Tool descriptions matter</p> <p>Plyra Guard uses the tool name + arguments to build the intent string. Clear tool names (e.g. <code>\"Delete File\"</code> not <code>\"df\"</code>) make policy rules easier to write and audit logs easier to read.</p> <p>Test your policy before running a crew</p> <p>Use <code>guard.evaluate(intent)</code> to dry-run your policy against expected tool calls before starting a long crew job.</p>"},{"location":"integrations/langgraph/","title":"LangGraph Integration","text":"<p>LangGraph's <code>ToolNode</code> uses internal state tracking that conflicts with transparent wrapping. The recommended pattern is a custom guarded tool node.</p>"},{"location":"integrations/langgraph/#why-custom-node","title":"Why Custom Node?","text":"<p>LangGraph's <code>ToolNode</code> directly invokes tools and manages <code>ToolMessage</code> state internally. Wrapping tools before passing them to <code>ToolNode</code> works for simple cases, but breaks message correlation in complex graphs. A custom node gives you full control.</p>"},{"location":"integrations/langgraph/#guarded-tool-node-pattern","title":"Guarded Tool Node Pattern","text":"<pre><code>from langchain_core.messages import ToolMessage\nfrom langchain_core.tools import tool\nfrom langgraph.graph import StateGraph, MessagesState, END\nfrom plyra_guard import ActionGuard\nfrom plyra_guard.exceptions import PolicyViolationError\n\nguard = ActionGuard()\n\n# Define your tools normally\n@tool\ndef read_file(path: str) -&gt; str:\n    \"\"\"Read a file from disk.\"\"\"\n    with open(path) as f:\n        return f.read()\n\n@tool\ndef delete_file(path: str) -&gt; str:\n    \"\"\"Delete a file from disk.\"\"\"\n    import os\n    os.remove(path)\n    return f\"Deleted {path}\"\n\nTOOLS = {t.name: t for t in [read_file, delete_file]}\n\n\ndef guarded_tool_node(state: MessagesState) -&gt; dict:\n    \"\"\"Custom tool node with Plyra Guard evaluation.\"\"\"\n    messages = []\n\n    for tool_call in state[\"messages\"][-1].tool_calls:\n        tool_name = tool_call[\"name\"]\n        tool_args = tool_call[\"args\"]\n        tool_id = tool_call[\"id\"]\n\n        # Build intent string for policy evaluation\n        intent = f\"{tool_name} {' '.join(str(v) for v in tool_args.values())}\"\n\n        try:\n            # Evaluate against policy first\n            result = guard.evaluate(intent)\n\n            if result.outcome == \"BLOCK\":\n                content = f\"[BLOCKED] {result.reason}\"\n            else:\n                # Policy allows \u2014 execute the real tool\n                actual_tool = TOOLS[tool_name]\n                content = actual_tool.invoke(tool_args)\n\n        except PolicyViolationError as e:\n            content = f\"[BLOCKED] {e}\"\n        except Exception as e:\n            content = f\"[ERROR] {e}\"\n\n        messages.append(\n            ToolMessage(content=str(content), tool_call_id=tool_id)\n        )\n\n    return {\"messages\": messages}\n\n\n# Wire into your graph\ndef should_continue(state: MessagesState) -&gt; str:\n    last = state[\"messages\"][-1]\n    return \"tools\" if last.tool_calls else END\n\n\ngraph = StateGraph(MessagesState)\ngraph.add_node(\"agent\", your_llm_node)\ngraph.add_node(\"tools\", guarded_tool_node)\ngraph.add_edge(\"__start__\", \"agent\")\ngraph.add_conditional_edges(\"agent\", should_continue)\ngraph.add_edge(\"tools\", \"agent\")\n\napp = graph.compile()\n</code></pre>"},{"location":"integrations/langgraph/#what-happens-on-a-block","title":"What Happens on a Block","text":"<p>When a tool is blocked, <code>guarded_tool_node</code> returns a <code>ToolMessage</code> with a <code>[BLOCKED]</code> prefix instead of raising an exception. This means:</p> <ul> <li>The graph continues running</li> <li>The LLM sees the block message and can course-correct</li> <li>Your graph topology doesn't break</li> </ul> <p>If you'd rather halt execution on a block, raise <code>PolicyViolationError</code> instead of returning a blocked message.</p>"},{"location":"integrations/langgraph/#with-a-custom-policy","title":"With a Custom Policy","text":"<pre><code>from plyra_guard import Policy, Rule\n\npolicy = Policy(rules=[\n    Rule(pattern=r\"delete_file /etc\", action=\"block\", reason=\"Cannot delete system files\"),\n    Rule(pattern=r\"delete_file /tmp\", action=\"allow\"),\n    Rule(pattern=r\"read_file\", action=\"allow\"),\n])\n\nguard = ActionGuard(policy=policy)\n</code></pre>"},{"location":"integrations/langgraph/#viewing-action-history","title":"Viewing Action History","text":"<pre><code># After your graph runs\nfor action in guard.history(limit=20):\n    print(f\"{action.tool_name} \u2192 {action.outcome} ({action.latency_ms}ms)\")\n</code></pre>"}]}